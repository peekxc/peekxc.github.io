---
title: "The Beauty of C++"
author: "Matt Piekenbrock"
date: '2017-03-01'
slug: the-beauty-of-cpp
include_toc: true
categories: ["C++"]
output: 
  html_document:
    keep_md: TRUE
    self_contained: TRUE
    highlight: kate
---

C++ is a beautiful language. There, I said it.

Before I get my inbox flooded with snippets of the ugliness of templates or links showing the differences, hear me out. 

## C++ is an apple, not an orange. 

C++ is typically thought of as an _ugly_ language. Many devs who say this will far too quickly point to examples showing how many more lines it takes to write something in C++ than in Python. For example, 

This is a straw-mans argument. C++ is a compiled language. Python, Ruby, R, Perl, etc. are interpreted languages. It is simply not fair to compare them. 

Let's assume the contrary, that it _is_ fair to compare them. After all, if two given sets of source code encode the same logic, 
why not start looking effiency-to-productivity ratios and maximize accordingly? 

One of the core principles that has always been a philosophical cornerstone of C++ is the principle of _zero-cost abstraction_. That is, the notion 
that if one intends to add something to the language, it ought to be better than any code 99% of programmers could code up themselves. More exactly, 
the code should not just add higher-order functionality---it must offer an abstraction that the programmer can use effectively at _zero_ (or near-zero) 
cost to themselves.

Here is a very deep statement: maintaining the _zero-cost abstraction_ principle is _hard_. It is _hard_ to write abstractions that come at no cost to the programmer. 

Let's see some examples. 

## Abstractions are easy. Good abstractions are hard. 

This begs the question, _how_ does one create an abstraction that is _zero-cost_? 

A famous quote that rings truer to closer one gets to the hardware is the following: 

```
All problems in computer science can be solved by another level of indirection... except for the problem of too many layers of indirection.
```

Well, to me there are two aspects to it, each being difficult in very different ways. 

There's the efficiency side of it: a zero-cost abstraction ought to be just as _efficient_ as something a programmer might write himeself. This, 
to me, comes down to an engineering problem---ensure the number of assembly instructions generated by the abstraction is minimal. 

Then, there's the much more difficult side of it: the _design_ aspect. The abstraction should solve a problem not already solved by other constructions. 
This is truly the most difficult aspect of all. [Design is a search problem](https://www.youtube.com/watch?v=fThhbt23SGM).

I'll quote Mike Bostock here: 

Talking about design is hard because design is hard. 

There's quite a lot of code out there. But every programmer who has thought about any previous code they've ever written has inevitably 
had the following experience: 

1. Write a function that does something 
2. Write a function that works with the first function 
3. Realize that the first function can be encapsulated by the second. 

Another aspect of design is the it is subjective. 

## What is working

Functional programming. Compile-time expressions. SFINAE and its emergent simplicity: https://www.youtube.com/watch?v=PFdWqa68LmA&feature=youtu.be

## The Monad example

Computer programming encodes logic. And anyone that studied functional programming knows that a sort of corner of of functional programming theory is 
something known _category theory_. 

Let's look at a simple example. 
std::optional and relationship to monad

Error codes and exception handling has been around for years. How does one approach the problem of handling the result of a function which 
may fail to produce an output. 

What if you want a function to return some object? A common approach is to create some kind 'null' object, or to return a pointer to the object 
and return a `nullptr`. 

In the former case, the object may be expensive to create. 

The latter case can be used, but it is hard to compose. You still need to perform checking somewhere: either 

preconditions 


## Navigating the stars 

Bartosz Mileweski proposed using Haskell as a language to design the TMP for C++. 

Picture of waveforms vs music notes. 

## More real-world examples

kdtools

## Conclusions

Anyone can create a simple language to do whatever abstraction they could dream of. 
The fact that C++ demands its abstractions to be zer-cost is a highly non-trivial constraint to satisfy. 
Yet time passes. Advances are made. The fact that the lambda was a game-changer 
C++ is an evolving language, and advances in making these abstractions is becoming more popular.
Indeed, there are some tasks that one can write incredibly concisely in modern C++ that is near the line-count 
and readability of some of the interpreted languages. And in all but pathological, misconstrewed examples, the C++ 
solution _will_ be faster than the interpreseted equivalents, by design. 

And how did that happen? Intrinsically simple, carefully thought out components were skillfully woven 
together in a way that carried no baggage, no extraneous cost. The result is simple to read, simple to 
write code that solves a complex problem by breaking it into simple parts. 
To me, that is what makes C++ a beautiful language. 
