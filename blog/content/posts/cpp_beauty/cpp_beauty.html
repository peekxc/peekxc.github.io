---
title: "The Beauty of C++"
author: "Matt Piekenbrock"
date: '2017-03-01'
slug: the-beauty-of-cpp
include_toc: true
categories: ["C++"]
output: 
  blogdown::html_page:
    keep_md: TRUE
    self_contained: FALSE
---



<p>Most code written today, in some way shape or form, is either written in or depends on C++.</p>
<p>This includes, for example, most of the modern interpreted languages.</p>
<p>C++ is a beautiful language. There, I said it.</p>
<p>Before I get my inbox flooded with snippets of the ugliness of templates or links showing the differences, hear me out.</p>
<div id="c-is-an-apple-not-an-orange." class="section level2">
<h2>C++ is an apple, not an orange.</h2>
<p>C++ is typically thought of as an <em>ugly</em> language. Many devs who say this will far too quickly point to examples showing how many more lines it takes to write something in C++ than in Python. For example,</p>
<p>This is a straw-mans argument. C++ is a compiled language. Python, Ruby, R, Perl, etc. are interpreted languages. It is simply not fair to compare them.</p>
<p>Let’s assume the contrary, that it <em>is</em> fair to compare them. After all, if two given sets of source code encode the same logic,
why not start looking effiency-to-productivity ratios and maximize accordingly?</p>
<p>One of the core principles that has always been a philosophical cornerstone of C++ is the principle of <em>zero-cost abstraction</em>. That is, the notion
that if one intends to add something to the language, it ought to be better than any code 99% of programmers could code up themselves. More exactly,
the code should not just add higher-order functionality—it must offer an abstraction that the programmer can use effectively at <em>zero</em> (or near-zero)
cost to themselves.</p>
<p>Here is a very deep statement: maintaining the <em>zero-cost abstraction</em> principle is <em>hard</em>. It is <em>hard</em> to write abstractions that come at no cost to the programmer.</p>
<p>Let’s see some examples.</p>
</div>
<div id="abstractions-are-easy.-good-abstractions-are-hard." class="section level2">
<h2>Abstractions are easy. Good abstractions are hard.</h2>
<p>This begs the question, <em>how</em> does one create an abstraction that is <em>zero-cost</em>?</p>
<p>A famous quote that rings truer to closer one gets to the hardware is the following:</p>
<pre><code>All problems in computer science can be solved by another level of indirection... except for the problem of too many layers of indirection.</code></pre>
<p>Well, to me there are two aspects to it, each being difficult in very different ways.</p>
<p>There’s the efficiency side of it: a zero-cost abstraction ought to be just as <em>efficient</em> as something a programmer might write himeself. This,
to me, comes down to an engineering problem—ensure the number of assembly instructions generated by the abstraction is minimal.</p>
<p>Then, there’s the much more difficult side of it: the <em>design</em> aspect. The abstraction should solve a problem not already solved by other constructions.
This is truly the most difficult aspect of all. <a href="https://www.youtube.com/watch?v=fThhbt23SGM">Design is a search problem</a>.</p>
<p>I’ll quote Mike Bostock here:</p>
<p>Talking about design is hard because design is hard.</p>
<p>There’s quite a lot of code out there. But every programmer who has thought about any previous code they’ve ever written has inevitably
had the following experience:</p>
<ol style="list-style-type: decimal">
<li>Write a function that does something</li>
<li>Write a function that works with the first function</li>
<li>Realize that the first function can be encapsulated by the second.</li>
</ol>
<p>Another aspect of design is the it is subjective.</p>
</div>
<div id="what-is-working" class="section level2">
<h2>What is working</h2>
<p>Functional programming. Compile-time expressions. SFINAE and its emergent simplicity: <a href="https://www.youtube.com/watch?v=PFdWqa68LmA&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=PFdWqa68LmA&amp;feature=youtu.be</a></p>
</div>
<div id="the-monad-example" class="section level2">
<h2>The Monad example</h2>
<p>Computer programming encodes logic. And anyone that studied functional programming knows that a sort of corner of of functional programming theory is
something known <em>category theory</em>.</p>
<p>Let’s look at a simple example.
std::optional and relationship to monad</p>
<p>Error codes and exception handling has been around for years. How does one approach the problem of handling the result of a function which
may fail to produce an output.</p>
<p>What if you want a function to return some object? A common approach is to create some kind ‘null’ object, or to return a pointer to the object
and return a <code>nullptr</code>.</p>
<p>In the former case, the object may be expensive to create.</p>
<p>The latter case can be used, but it is hard to compose. You still need to perform checking somewhere: either</p>
<p>preconditions</p>
</div>
<div id="navigating-the-stars" class="section level2">
<h2>Navigating the stars</h2>
<p>Bartosz Mileweski proposed using Haskell as a language to design the TMP for C++.</p>
<p>Picture of waveforms vs music notes.</p>
</div>
<div id="more-real-world-examples" class="section level2">
<h2>More real-world examples</h2>
<p>kdtools</p>
</div>
<div id="conclusions" class="section level2">
<h2>Conclusions</h2>
<p>Anyone can create a simple language to do whatever abstraction they could dream of.
The fact that C++ demands its abstractions to be zer-cost is a highly non-trivial constraint to satisfy.
Yet time passes. Advances are made. The fact that the lambda was a game-changer
C++ is an evolving language, and advances in making these abstractions is becoming more popular.
Indeed, there are some tasks that one can write incredibly concisely in modern C++ that is near the line-count
and readability of some of the interpreted languages. And in all but pathological, misconstrewed examples, the C++
solution <em>will</em> be faster than the interpreseted equivalents, by design.</p>
<p>And how did that happen? Intrinsically simple, carefully thought out components were skillfully woven
together in a way that carried no baggage, no extraneous cost. The result is simple to read, simple to
write code that solves a complex problem by breaking it into simple parts.
To me, that is what makes C++ a beautiful language.</p>
</div>
